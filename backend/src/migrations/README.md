# Backend Migrations Directory

## Vis√£o Geral

Este diret√≥rio cont√©m as migra√ß√µes do banco de dados para a aplica√ß√£o Health Guardian. As migra√ß√µes s√£o respons√°veis por versionar e aplicar mudan√ßas incrementais no schema do banco de dados, garantindo que todas as inst√¢ncias da aplica√ß√£o tenham a mesma estrutura de dados.

## Estrutura de Migra√ß√µes

### Conven√ß√£o de Nomenclatura
```
YYYYMMDDHHMMSS-description-of-change.js
```

**Exemplo**: `20241201120000-create-users-table.js`

### Migra√ß√µes Existentes

#### `20241201000001-create-users-table.js`
**Prop√≥sito**: Criar tabela de usu√°rios do sistema.

**Estrutura**:
- `id`: Chave prim√°ria (UUID)
- `name`: Nome completo
- `email`: Email √∫nico
- `password`: Senha hasheada
- `role`: Papel no sistema (admin, doctor, nurse)
- `isActive`: Status ativo/inativo
- `createdAt`, `updatedAt`: Timestamps

**Conectores**:
- **Auth**: Base para sistema de autentica√ß√£o
- **Records**: Referenciado em registros m√©dicos
- **Alerts**: Destinat√°rio de alertas

#### `20241201000002-create-patients-table.js`
**Prop√≥sito**: Criar tabela de pacientes.

**Estrutura**:
- `id`: Chave prim√°ria (UUID)
- `name`: Nome completo
- `cpf`: CPF √∫nico
- `birthDate`: Data de nascimento
- `gender`: G√™nero (M/F/O)
- `phone`: Telefone de contato
- `email`: Email do paciente
- `address`: Endere√ßo (JSONB)
- `emergencyContact`: Contato de emerg√™ncia (JSONB)
- `medicalHistory`: Hist√≥rico m√©dico (JSONB)
- `isActive`: Status ativo/inativo
- `createdAt`, `updatedAt`: Timestamps

**Conectores**:
- **Records**: Chave estrangeira em registros
- **Alerts**: Destinat√°rio de alertas
- **AI**: Contexto para an√°lises

#### `20241201000003-create-records-table.js`
**Prop√≥sito**: Criar tabela de registros m√©dicos.

**Estrutura**:
- `id`: Chave prim√°ria (UUID)
- `patientId`: FK para pacientes
- `doctorId`: FK para usu√°rios (m√©dico)
- `type`: Tipo de registro (consultation, exam, prescription)
- `date`: Data do registro
- `content`: Conte√∫do estruturado (TEXT)
- `tags`: Tags aplicadas (ARRAY)
- `status`: Status do registro
- `metadata`: Metadados adicionais (JSONB)
- `createdAt`, `updatedAt`: Timestamps

**Conectores**:
- **Patients**: Vinculado via patientId
- **Users**: Vinculado via doctorId
- **Tags**: Aplica√ß√£o de tags
- **AI**: Base para an√°lises

#### `20241201000004-create-tags-table.js`
**Prop√≥sito**: Criar tabela de defini√ß√µes de tags.

**Estrutura**:
- `id`: Chave prim√°ria (UUID)
- `name`: Nome da tag
- `category`: Categoria (specialty, condition, procedure)
- `color`: Cor para UI
- `description`: Descri√ß√£o da tag
- `isActive`: Status ativo/inativo
- `createdAt`, `updatedAt`: Timestamps

**Conectores**:
- **Records**: Aplicadas em registros
- **Search**: Facilita busca e filtros
- **UI**: Exibi√ß√£o visual

#### `20241201000005-create-templates-table.js`
**Prop√≥sito**: Criar tabela de templates de documentos.

**Estrutura**:
- `id`: Chave prim√°ria (UUID)
- `name`: Nome do template
- `category`: Categoria do template
- `specialty`: Especialidade m√©dica
- `content`: Conte√∫do do template (TEXT)
- `tags`: Tags associadas (ARRAY)
- `isActive`: Status ativo/inativo
- `createdBy`: FK para usu√°rio criador
- `createdAt`, `updatedAt`: Timestamps

**Conectores**:
- **Records**: Base para novos registros
- **Users**: Criado por usu√°rio
- **AI**: Contexto para sugest√µes

#### `20241201000006-create-alerts-table.js`
**Prop√≥sito**: Criar tabela de alertas e notifica√ß√µes.

**Estrutura**:
- `id`: Chave prim√°ria (UUID)
- `patientId`: FK para paciente (opcional)
- `userId`: FK para usu√°rio destinat√°rio
- `type`: Tipo de alerta (medication, appointment, exam)
- `priority`: Prioridade (low, medium, high, critical)
- `title`: T√≠tulo do alerta
- `message`: Mensagem detalhada
- `scheduledFor`: Data/hora agendada
- `sentAt`: Data/hora de envio
- `readAt`: Data/hora de leitura
- `isActive`: Status ativo/inativo
- `metadata`: Metadados adicionais (JSONB)
- `createdAt`, `updatedAt`: Timestamps

**Conectores**:
- **Patients**: Vinculado via patientId
- **Users**: Destinat√°rio via userId
- **Rules**: Baseado em regras de neg√≥cio

#### `20241201000007-create-calculators-table.js`
**Prop√≥sito**: Criar tabela de calculadoras m√©dicas.

**Estrutura**:
- `id`: Chave prim√°ria (UUID)
- `name`: Nome da calculadora
- `category`: Categoria m√©dica
- `description`: Descri√ß√£o da funcionalidade
- `formula`: F√≥rmula de c√°lculo (TEXT)
- `parameters`: Par√¢metros de entrada (JSONB)
- `units`: Unidades de medida (JSONB)
- `references`: Refer√™ncias cient√≠ficas (JSONB)
- `isActive`: Status ativo/inativo
- `createdBy`: FK para usu√°rio criador
- `createdAt`, `updatedAt`: Timestamps

**Conectores**:
- **AI**: Integra√ß√£o com an√°lises
- **Records**: Resultados salvos em registros
- **Users**: Criado por usu√°rio

## Estrutura de Migra√ß√£o Padr√£o

```javascript
'use strict';

/**
 * Migration: [Nome da Migra√ß√£o]
 * 
 * Prop√≥sito: [Descri√ß√£o das mudan√ßas no schema]
 * 
 * Conectores:
 * - Cria/modifica tabela [nome] para [prop√≥sito]
 * - Integra com [tabela/servi√ßo] via [relacionamento]
 * - Usado por [funcionalidade] para [finalidade]
 * 
 * @author Health Guardian Team
 * @since 1.0.0
 */

module.exports = {
  up: async (queryInterface, Sequelize) => {
    const { DataTypes } = Sequelize;
    
    try {
      console.log('üîÑ Executando migra√ß√£o: [nome]...');
      
      await queryInterface.createTable('[table_name]', {
        id: {
          type: DataTypes.UUID,
          defaultValue: DataTypes.UUIDV4,
          primaryKey: true,
          allowNull: false
        },
        
        // Campos espec√≠ficos da tabela
        
        createdAt: {
          type: DataTypes.DATE,
          allowNull: false,
          defaultValue: Sequelize.literal('CURRENT_TIMESTAMP')
        },
        updatedAt: {
          type: DataTypes.DATE,
          allowNull: false,
          defaultValue: Sequelize.literal('CURRENT_TIMESTAMP')
        }
      });
      
      // Criar √≠ndices
      await queryInterface.addIndex('[table_name]', ['field1', 'field2']);
      
      // Adicionar constraints
      await queryInterface.addConstraint('[table_name]', {
        fields: ['field'],
        type: 'unique',
        name: '[table_name]_field_unique'
      });
      
      console.log('‚úÖ Migra√ß√£o [nome] conclu√≠da com sucesso');
      
    } catch (error) {
      console.error('‚ùå Erro na migra√ß√£o [nome]:', error);
      throw error;
    }
  },

  down: async (queryInterface, Sequelize) => {
    try {
      console.log('üîÑ Revertendo migra√ß√£o: [nome]...');
      
      // Remover constraints
      await queryInterface.removeConstraint('[table_name]', '[table_name]_field_unique');
      
      // Remover √≠ndices
      await queryInterface.removeIndex('[table_name]', ['field1', 'field2']);
      
      // Remover tabela
      await queryInterface.dropTable('[table_name]');
      
      console.log('‚úÖ Migra√ß√£o [nome] revertida com sucesso');
      
    } catch (error) {
      console.error('‚ùå Erro ao reverter migra√ß√£o [nome]:', error);
      throw error;
    }
  }
};
```

## Tipos de Migra√ß√µes

### 1. Cria√ß√£o de Tabelas
```javascript
// Criar nova tabela
await queryInterface.createTable('table_name', {
  id: {
    type: DataTypes.UUID,
    defaultValue: DataTypes.UUIDV4,
    primaryKey: true
  },
  name: {
    type: DataTypes.STRING(255),
    allowNull: false
  },
  email: {
    type: DataTypes.STRING(255),
    allowNull: false,
    unique: true,
    validate: {
      isEmail: true
    }
  },
  isActive: {
    type: DataTypes.BOOLEAN,
    defaultValue: true
  },
  metadata: {
    type: DataTypes.JSONB,
    defaultValue: {}
  },
  createdAt: {
    type: DataTypes.DATE,
    allowNull: false
  },
  updatedAt: {
    type: DataTypes.DATE,
    allowNull: false
  }
});
```

### 2. Adi√ß√£o de Colunas
```javascript
// Adicionar nova coluna
await queryInterface.addColumn('table_name', 'new_column', {
  type: DataTypes.STRING(100),
  allowNull: true,
  defaultValue: null
});

// Adicionar m√∫ltiplas colunas
await queryInterface.addColumn('table_name', 'column1', {
  type: DataTypes.INTEGER,
  allowNull: false,
  defaultValue: 0
});

await queryInterface.addColumn('table_name', 'column2', {
  type: DataTypes.TEXT,
  allowNull: true
});
```

### 3. Modifica√ß√£o de Colunas
```javascript
// Alterar tipo de coluna
await queryInterface.changeColumn('table_name', 'column_name', {
  type: DataTypes.TEXT, // Novo tipo
  allowNull: false      // Nova configura√ß√£o
});

// Renomear coluna
await queryInterface.renameColumn('table_name', 'old_name', 'new_name');
```

### 4. Remo√ß√£o de Colunas
```javascript
// Remover coluna
await queryInterface.removeColumn('table_name', 'column_name');

// Remover m√∫ltiplas colunas
await queryInterface.removeColumn('table_name', 'column1');
await queryInterface.removeColumn('table_name', 'column2');
```

### 5. √çndices
```javascript
// Adicionar √≠ndice simples
await queryInterface.addIndex('table_name', ['column_name']);

// Adicionar √≠ndice composto
await queryInterface.addIndex('table_name', ['column1', 'column2'], {
  name: 'table_name_column1_column2_idx',
  unique: false
});

// Adicionar √≠ndice √∫nico
await queryInterface.addIndex('table_name', ['email'], {
  name: 'table_name_email_unique_idx',
  unique: true
});

// Remover √≠ndice
await queryInterface.removeIndex('table_name', 'index_name');
```

### 6. Constraints
```javascript
// Adicionar constraint de chave estrangeira
await queryInterface.addConstraint('records', {
  fields: ['patientId'],
  type: 'foreign key',
  name: 'records_patient_fk',
  references: {
    table: 'patients',
    field: 'id'
  },
  onDelete: 'CASCADE',
  onUpdate: 'CASCADE'
});

// Adicionar constraint unique
await queryInterface.addConstraint('users', {
  fields: ['email'],
  type: 'unique',
  name: 'users_email_unique'
});

// Adicionar constraint check
await queryInterface.addConstraint('patients', {
  fields: ['gender'],
  type: 'check',
  name: 'patients_gender_check',
  where: {
    gender: ['M', 'F', 'O']
  }
});

// Remover constraint
await queryInterface.removeConstraint('table_name', 'constraint_name');
```

### 7. Dados Iniciais
```javascript
// Inserir dados iniciais (usar com cuidado)
await queryInterface.bulkInsert('table_name', [
  {
    id: '550e8400-e29b-41d4-a716-446655440000',
    name: 'Admin',
    email: 'admin@healthguardian.com',
    role: 'admin',
    createdAt: new Date(),
    updatedAt: new Date()
  }
]);

// Atualizar dados existentes
await queryInterface.bulkUpdate('table_name', 
  { isActive: false }, // Valores para atualizar
  { role: 'deprecated' } // Condi√ß√µes
);

// Remover dados
await queryInterface.bulkDelete('table_name', {
  isActive: false
});
```

## Comandos de Migra√ß√£o

### Sequelize CLI
```bash
# Gerar nova migra√ß√£o
npx sequelize-cli migration:generate --name create-table-name

# Executar migra√ß√µes pendentes
npx sequelize-cli db:migrate

# Reverter √∫ltima migra√ß√£o
npx sequelize-cli db:migrate:undo

# Reverter todas as migra√ß√µes
npx sequelize-cli db:migrate:undo:all

# Reverter at√© migra√ß√£o espec√≠fica
npx sequelize-cli db:migrate:undo:all --to 20241201000003-create-records-table.js

# Status das migra√ß√µes
npx sequelize-cli db:migrate:status
```

### Scripts Personalizados
```javascript
// scripts/migrate.js
const { sequelize } = require('../config/database-pg');
const { Umzug, SequelizeStorage } = require('umzug');
const path = require('path');

const umzug = new Umzug({
  migrations: {
    glob: path.join(__dirname, '../migrations/*.js')
  },
  context: sequelize.getQueryInterface(),
  storage: new SequelizeStorage({ sequelize }),
  logger: console
});

const runMigrations = async (direction = 'up') => {
  try {
    console.log(`üîÑ Executando migra√ß√µes (${direction})...`);
    
    if (direction === 'up') {
      await umzug.up();
      console.log('‚úÖ Todas as migra√ß√µes executadas com sucesso!');
    } else {
      await umzug.down();
      console.log('‚úÖ Migra√ß√£o revertida com sucesso!');
    }
    
  } catch (error) {
    console.error('‚ùå Erro nas migra√ß√µes:', error);
    process.exit(1);
  } finally {
    await sequelize.close();
  }
};

if (require.main === module) {
  const direction = process.argv[2] || 'up';
  runMigrations(direction);
}

module.exports = { runMigrations, umzug };
```

## Mapa de Integra√ß√µes

```
migrations/
‚îú‚îÄ‚îÄ 20241201000001-create-users-table.js
‚îÇ   ‚îú‚îÄ‚îÄ ‚Üí models/User.js (defini√ß√£o modelo)
‚îÇ   ‚îú‚îÄ‚îÄ ‚Üí auth/ (sistema autentica√ß√£o)
‚îÇ   ‚îî‚îÄ‚îÄ ‚Üí records/ (FK doctorId)
‚îÇ
‚îú‚îÄ‚îÄ 20241201000002-create-patients-table.js
‚îÇ   ‚îú‚îÄ‚îÄ ‚Üí models/Patient.js (defini√ß√£o modelo)
‚îÇ   ‚îú‚îÄ‚îÄ ‚Üí records/ (FK patientId)
‚îÇ   ‚îî‚îÄ‚îÄ ‚Üí alerts/ (FK patientId)
‚îÇ
‚îú‚îÄ‚îÄ 20241201000003-create-records-table.js
‚îÇ   ‚îú‚îÄ‚îÄ ‚Üí models/Record.js (defini√ß√£o modelo)
‚îÇ   ‚îú‚îÄ‚îÄ ‚Üí patients/ (FK patientId)
‚îÇ   ‚îú‚îÄ‚îÄ ‚Üí users/ (FK doctorId)
‚îÇ   ‚îî‚îÄ‚îÄ ‚Üí ai/ (an√°lise conte√∫do)
‚îÇ
‚îú‚îÄ‚îÄ 20241201000004-create-tags-table.js
‚îÇ   ‚îú‚îÄ‚îÄ ‚Üí models/Tag.js (defini√ß√£o modelo)
‚îÇ   ‚îú‚îÄ‚îÄ ‚Üí records/ (aplica√ß√£o tags)
‚îÇ   ‚îî‚îÄ‚îÄ ‚Üí search/ (filtros)
‚îÇ
‚îú‚îÄ‚îÄ 20241201000005-create-templates-table.js
‚îÇ   ‚îú‚îÄ‚îÄ ‚Üí models/Template.js (defini√ß√£o modelo)
‚îÇ   ‚îú‚îÄ‚îÄ ‚Üí records/ (base registros)
‚îÇ   ‚îî‚îÄ‚îÄ ‚Üí ai/ (contexto)
‚îÇ
‚îú‚îÄ‚îÄ 20241201000006-create-alerts-table.js
‚îÇ   ‚îú‚îÄ‚îÄ ‚Üí models/Alert.js (defini√ß√£o modelo)
‚îÇ   ‚îú‚îÄ‚îÄ ‚Üí patients/ (FK patientId)
‚îÇ   ‚îú‚îÄ‚îÄ ‚Üí users/ (FK userId)
‚îÇ   ‚îî‚îÄ‚îÄ ‚Üí rules/ (trigger alertas)
‚îÇ
‚îî‚îÄ‚îÄ 20241201000007-create-calculators-table.js
    ‚îú‚îÄ‚îÄ ‚Üí models/Calculator.js (defini√ß√£o modelo)
    ‚îú‚îÄ‚îÄ ‚Üí ai/ (integra√ß√£o an√°lises)
    ‚îî‚îÄ‚îÄ ‚Üí records/ (salvar resultados)
```

## Versionamento e Controle

### Estrat√©gia de Versionamento
```javascript
// Cada migra√ß√£o deve ter timestamp √∫nico
const timestamp = new Date().toISOString()
  .replace(/[-:]/g, '')
  .replace(/\..+/, '');

// Formato: YYYYMMDDHHMMSS
// Exemplo: 20241201143022
```

### Controle de Estado
```javascript
// Verificar se migra√ß√£o j√° foi executada
const checkMigrationStatus = async (migrationName) => {
  const [results] = await sequelize.query(
    'SELECT * FROM "SequelizeMeta" WHERE name = ?',
    {
      replacements: [migrationName],
      type: sequelize.QueryTypes.SELECT
    }
  );
  
  return results.length > 0;
};

// Marcar migra√ß√£o como executada
const markMigrationComplete = async (migrationName) => {
  await sequelize.query(
    'INSERT INTO "SequelizeMeta" (name) VALUES (?)',
    {
      replacements: [migrationName],
      type: sequelize.QueryTypes.INSERT
    }
  );
};
```

## Valida√ß√£o e Testes

### Valida√ß√£o de Schema
```javascript
// Validar estrutura ap√≥s migra√ß√£o
const validateTableStructure = async (tableName, expectedColumns) => {
  const tableInfo = await queryInterface.describeTable(tableName);
  
  for (const column of expectedColumns) {
    if (!tableInfo[column.name]) {
      throw new Error(`Coluna ${column.name} n√£o encontrada em ${tableName}`);
    }
    
    if (tableInfo[column.name].type !== column.type) {
      throw new Error(`Tipo incorreto para ${column.name}: esperado ${column.type}, encontrado ${tableInfo[column.name].type}`);
    }
  }
  
  console.log(`‚úÖ Estrutura da tabela ${tableName} validada`);
};
```

### Testes de Migra√ß√£o
```javascript
// tests/migrations.test.js
const { sequelize } = require('../src/config/database-pg');
const { umzug } = require('../src/scripts/migrate');

describe('Database Migrations', () => {
  beforeEach(async () => {
    // Reset database
    await sequelize.drop();
    await sequelize.sync();
  });
  
  test('should run all migrations successfully', async () => {
    await umzug.up();
    
    // Verificar se todas as tabelas foram criadas
    const tables = await sequelize.getQueryInterface().showAllTables();
    expect(tables).toContain('users');
    expect(tables).toContain('patients');
    expect(tables).toContain('records');
  });
  
  test('should rollback migrations correctly', async () => {
    await umzug.up();
    await umzug.down();
    
    const tables = await sequelize.getQueryInterface().showAllTables();
    expect(tables).not.toContain('users');
  });
  
  test('should handle foreign key constraints', async () => {
    await umzug.up();
    
    // Tentar inserir registro com FK inv√°lida
    await expect(
      sequelize.query(
        'INSERT INTO records (id, "patientId", content) VALUES (?, ?, ?)',
        {
          replacements: ['550e8400-e29b-41d4-a716-446655440000', 'invalid-id', 'test'],
          type: sequelize.QueryTypes.INSERT
        }
      )
    ).rejects.toThrow();
  });
});
```

## Depend√™ncias

- **sequelize**: ORM para opera√ß√µes de banco
- **sequelize-cli**: CLI para migra√ß√µes
- **umzug**: Gerenciador de migra√ß√µes (alternativo)
- **pg**: Driver PostgreSQL
- **uuid**: Gera√ß√£o de IDs √∫nicos

## Hook de Teste

### Cobertura de Testes
```javascript
// Hook: Testa integridade referencial e constraints
const testMigrationIntegrity = async () => {
  // Testar constraints de FK
  // Testar √≠ndices √∫nicos
  // Testar valida√ß√µes de dados
  // Testar rollback completo
};
```

## IA Prompt Sugerido

```
IA prompt: "Crie uma nova migra√ß√£o para [altera√ß√£o espec√≠fica], incluindo valida√ß√£o de dados, tratamento de rollback, √≠ndices apropriados e documenta√ß√£o completa. Siga os padr√µes estabelecidos e considere impactos em dados existentes."
```

## Seguran√ßa e Performance

### Boas Pr√°ticas
```javascript
// 1. Sempre usar transa√ß√µes para opera√ß√µes complexas
const transaction = await queryInterface.sequelize.transaction();
try {
  await queryInterface.createTable('table1', schema, { transaction });
  await queryInterface.createTable('table2', schema, { transaction });
  await transaction.commit();
} catch (error) {
  await transaction.rollback();
  throw error;
}

// 2. Criar √≠ndices para colunas frequentemente consultadas
await queryInterface.addIndex('records', ['patientId', 'date']);

// 3. Usar JSONB para dados semi-estruturados
metadata: {
  type: DataTypes.JSONB,
  defaultValue: {}
}

// 4. Definir constraints apropriadas
await queryInterface.addConstraint('users', {
  fields: ['email'],
  type: 'unique',
  name: 'users_email_unique'
});
```

### Otimiza√ß√£o de Performance
```javascript
// √çndices parciais para dados ativos
await queryInterface.addIndex('patients', ['isActive'], {
  name: 'patients_active_idx',
  where: {
    isActive: true
  }
});

// √çndices compostos para consultas complexas
await queryInterface.addIndex('records', ['patientId', 'type', 'date'], {
  name: 'records_patient_type_date_idx'
});
```

## Troubleshooting

### Problemas Comuns
1. **Constraint Violations**: Verificar dados existentes antes de adicionar constraints
2. **Type Mismatches**: Validar compatibilidade de tipos ao alterar colunas
3. **Index Conflicts**: Verificar se √≠ndices j√° existem antes de criar
4. **Foreign Key Errors**: Garantir que tabelas referenciadas existam

### Debug e Logs
```javascript
// Habilitar logs detalhados
const sequelize = new Sequelize(config.database, config.username, config.password, {
  ...config,
  logging: (sql, timing) => {
    console.log(`[${new Date().toISOString()}] ${sql}`);
    if (timing) console.log(`Execution time: ${timing}ms`);
  }
});
```